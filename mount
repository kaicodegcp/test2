reclaim_and_merge_lv.sh
#!/bin/bash

set -e

echo "[INFO] Stopping Docker and related services..."
systemctl stop docker || true

echo "[INFO] Unmounting target mount points..."
umount -lf /opt/Cloudera || true
umount -lf /opt/cloudera || true
umount -lf /var/app/bigdata || true
umount -lf /var/app/log || true
umount -lf /docker || true
umount -lf /docker3 || true
umount -lf /opt/cgfiles || true

echo "[INFO] Removing old LVs..."
lvremove -y /dev/datavg/lv_opt_Cloudera || true
lvremove -y /dev/datavg/lv_opt_cloudera || true
lvremove -y /dev/datavg/lv_var_app_bigdata || true
lvremove -y /dev/datavg/lv_var_app_log || true
lvremove -y /dev/datavg/lv_docker || true
lvremove -y /dev/datavg/lv_docker3 || true
lvremove -y /dev/datavg/lv_opt_cgfiles || true

echo "[INFO] Refreshing VG space..."
vgdisplay datavg | grep "Free  PE"

echo "[INFO] Creating new consolidated LV: lv_docker_combined..."
lvcreate -l 100%FREE -n lv_docker_combined datavg

echo "[INFO] Formatting new LV with XFS..."
mkfs.xfs /dev/datavg/lv_docker_combined

echo "[INFO] Creating /docker mount point..."
mkdir -p /docker

echo "[INFO] Mounting /docker..."
mount /dev/datavg/lv_docker_combined /docker

echo "[INFO] Updating /etc/fstab for persistence..."
grep -q "lv_docker_combined" /etc/fstab || echo "/dev/mapper/datavg-lv_docker_combined /docker xfs defaults 0 0" >> /etc/fstab

echo "[INFO] Final mounted filesystems:"
df -hT | grep docker

echo "[‚úÖ COMPLETED] All requested volumes consolidated under /docker"




============================================


umount /docker
lvremove -y /dev/mapper/datavg-lv_docker_combined

lvcreate -L 400G -n lv_docker_combined datavg
mkfs.xfs /dev/mapper/datavg-lv_docker_combined
mkdir -p /docker
mount /dev/mapper/datavg-lv_docker_combined /docker

lvextend -L 990G /dev/mapper/datavg-lv_docker2
xfs_growfs /docker2

df -h | grep -E 'docker2|docker'


=====================================

mkdir /tmp/missing
for img in /docker/1.5.5/images/*.tar.gz; do
    name=$(basename "$img" .tar.gz)
    docker images | grep -q "$name"
    if [ $? -ne 0 ]; then
        echo "$img" >> /tmp/missing/not_loaded.txt
    fi
done

cat /tmp/missing/not_loaded.txt

#!/bin/bash

# Load missing Docker images from a list
INPUT_FILE="/tmp/missing/not_loaded.txt"

echo "=== Starting Docker image load from $INPUT_FILE ==="

if [[ ! -f "$INPUT_FILE" ]]; then
    echo "‚ùå Input file not found: $INPUT_FILE"
    exit 1
fi

while read -r tarfile; do
    if [[ -f "$tarfile" ]]; then
        echo "‚û°Ô∏è Loading $tarfile ..."
        docker load -i "$tarfile"
        if [[ $? -eq 0 ]]; then
            echo "‚úÖ Successfully loaded: $tarfile"
        else
            echo "‚ùå Failed to load: $tarfile"
        fi
    else
        echo "‚ö†Ô∏è File not found: $tarfile"
    fi
done < "$INPUT_FILE"

echo "=== Docker image loading complete ==="


==================================

#!/bin/bash

# Internal registry
INTERNAL_REG="sd-wv58-kflz.nam.nsroot.net:5000"

# Input file with images to process
IMAGE_LIST="file4.txt"

echo "=== Starting re-tag + push + cleanup for Docker images ==="

while read -r old_img; do
  # Extract image path after the AWS/ECR domain
  suffix=$(echo "$old_img" | sed -E 's|.*amazonaws.com/||')

  # Compose new internal tag
  new_img="${INTERNAL_REG}/${suffix}"

  echo "-----------------------------------------"
  echo "üîÑ Retagging:   $old_img --> $new_img"
  docker tag "$old_img" "$new_img"

  echo "üì§ Pushing:     $new_img"
  docker push "$new_img"

  echo "üßπ Removing old tag: $old_img"
  docker rmi "$old_img"

done < "$IMAGE_LIST"

echo "‚úÖ Done. All images re-tagged, pushed, and cleaned up."


=====
./retag_push_clean.sh
